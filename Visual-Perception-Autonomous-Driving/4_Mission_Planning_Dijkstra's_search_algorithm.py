# -*- coding: utf-8 -*-
"""Mission Planning - Dijkstra's search algorithm.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qduuHQG7ZYBoD4R3XC1DWz3BvJXFXQQl

# **Mission Planning - Dijkstra's search algorithm**

In this notebook, we will implement Dijkstra's search algorithm on a road network in Berkeley, California. We will then modify that algorithm using a distance heuristic to perform A* search. We will then get a chance to compare our shortest path to the mapping library's path.

**In this notebook, we will:**
* Implement Dijkstra's search algorithm on a road network graph.

* Implement the A* search algorithm using a Euclidean heuristic on a road network graph.

In this project, we will be relying on the [OSMNX library](https://osmnx.readthedocs.io/en/stable/) to generate Python graphs from Open Street Map (OSM) data. These graphs will be represented using the [NetworkX library](https://networkx.github.io/documentation/stable/). Both of these links are to the documentation, which you will find useful in this assessment.
"""

import osmnx as ox
import networkx as nx
import queue
import math
import priority_dict

"""We're going to be focusing on planning in Berkeley, California, between the two nodes given below. After running the code up to and including the box below, we should see the output of the shortest path between the two points. Our goal is to get the same output when implementing Dijkstra's and A* algorithm."""

map_graph = ox.graph_from_place('Berkeley, California', network_type='drive')
origin = ox.get_nearest_node(map_graph, (37.8743, -122.277))
destination = list(map_graph.nodes())[-1]

shortest_path = nx.shortest_path(map_graph, origin, destination, weight='length')
fig, ax = ox.plot_graph_route(map_graph, shortest_path)

"""## Dijkstra's Search

This function will be implemented in `dijkstras_search()`. We have included a helper function `get_path()` that will assist in retrieving the path from the dictionary of predecessors once the goal is found.

To perform Dijkstra's search, we require a priority queue (or a min heap), which is defined as the `priority_dict` class. This class is accessed just as a standard dictionary is, except it orders the keys by their value. We can use the vertices as the keys to our priority queue, and their distance from the start as their value. For example, to set the distance of vertex `v` to the variable `dist`, we can do `open_queue[v] = dist`. To get the smallest value in the priority queue, we can use `priority_dict.pop_smallest()`. This returns a tuple of the vertex key and it's distance from the origin.

The main input to the search is the `graph`, an OSMNX graph representation of the road network. The vertices are stored as keys, and as such the origin is given as `origin_key` and the goal is given as `goal_key`. To get the outgoing edges of a given vertex `u`, we can use `graph.out_edges([u], data=True)`. The return value of this is a list of tuples, each of which represent an outgoing edge. The second element of each tuple is the outgoing vertex at the other end of the edge. You can iterate over this list of tuples using:

`for edge in graph.out_edges([u], data=True):`

and can get the outgoing vertex of these edges by accessing the 2nd element of the tuple:

`edge[1]`.

To get the weight of this edge, you can access the data stored in the 3rd element of the tuple:

`length = edge[2]['length']`.

For more details, you can refer to the NetworkX documentation [here](https://networkx.github.io/documentation/networkx-2.3/reference/classes/generated/networkx.DiGraph.out_edges.html?highlight=out_edges#networkx.DiGraph.out_edges).

Your goal now is to find the shortest path in the graph from the origin to the goal using Dijkstra's search. Make sure to store the optimal predecessors of each vertex in the `predecessors` dictionary, so that we can retrieve the optimal path once we find the goal node in your search. Good luck!
"""

# for a given graph, origin vertex key, and goal vertex key,
# computes the shortest path in the graph from the origin vertex
# to the goal vertex using Dijkstra's algorithm.
# returns the shortest path as a list of vertex keys.
def dijkstras_search(origin_key, goal_key, graph):

    # the priority queue of open vertices we've reached.
    # keys are the vertex keys, vals are the distances.
    open_queue = priority_dict.priority_dict({})

    # the dictionary of closed vertices we've processed.
    closed_dict = {}

    # the dictionary of predecessors for each vertex.
    predecessors = {}

    # add the origin to the open queue.
    open_queue[origin_key] = 0.0

    # iterate through the open queue, until we find the goal.
    # each time, perform a Dijkstra's update on the queue.
    # todo: Implement the Dijstra update loop.
    goal_found = False
    while (open_queue):
        u, ucost = open_queue.pop_smallest()
        if u == goal_key:
            goal_found = True
            break
        for edge_dict in graph.out_edges([u], data=True):
            v = edge_dict[1]
            if v in closed_dict:
                continue
            uvcost = edge_dict[2]['length']
            if v not in open_queue:
                open_queue[v] = ucost + uvcost
                predecessors[v] = u
            else:
                vcost = open_queue[v]
                if ucost + uvcost < vcost:
                    open_queue[v] = ucost + uvcost
                    predecessors[v] = u
        closed_dict[u] = 1

    # if we get through entire priority queue without finding the goal,
    # something is wrong.
    if not goal_found:
        raise ValueError("Goal not found in search.")

    # construct the path from the predecessors dictionary.
    return get_path(origin_key, goal_key, predecessors)

# this function follows the predecessor
# backpointers and generates the equivalent path from the
# origin as a list of vertex keys.
def get_path(origin_key, goal_key, predecessors):
    key = goal_key
    path = [goal_key]

    while (key != origin_key):
        key = predecessors[key]
        path.insert(0, key)
    return path

"""Once these two functions have been implemented, we run the box below to see if our output matches that of the library function above. If it doesn't, we've made a mistake with our implementation."""

path = dijkstras_search(origin, destination, map_graph)
fig, ax = ox.plot_graph_route(map_graph, path)

"""## A* Search
Next, we will use a distance heuristic to implement A* search for our map search problem. Since we are using real map data here, we will need to convert the data to a format which we can use for distance computation. Each data point has a latitude and longitude associated with it, which we then have to convert into (x, y, z) coordinates on the earth (which we will assume to be a sphere with radius 6371 km). We can then take the straight line distance between these two points as an approximation for the distance between them. Over small distances, this approximation is accurate. This is implemented in the `distance_heuristic()` function below.
"""

# computes the Euclidean distance between two vertices.
# assume that the earth is a sphere with radius 6371 km.
def distance_heuristic(state_key, goal_key, node_data):
    n1 = node_data[state_key]
    n2 = node_data[goal_key]

    # get the longitude and latitude for each vertex.
    long1 = n1['x']*math.pi/180.0
    lat1 = n1['y']*math.pi/180.0
    long2 = n2['x']*math.pi/180.0
    lat2 = n2['y']*math.pi/180.0

    # use a spherical approximation of the earth for
    # estimating the distance between two points.
    r = 6371000
    x1 = r*math.cos(lat1)*math.cos(long1)
    y1 = r*math.cos(lat1)*math.sin(long1)
    z1 = r*math.sin(lat1)

    x2 = r*math.cos(lat2)*math.cos(long2)
    y2 = r*math.cos(lat2)*math.sin(long2)
    z2 = r*math.sin(lat2)

    d = ((x2-x1)**2 + (y2-y1)**2 + (z2-z1)**2)**0.5
    return d

"""Now, we can use our distance heuristic to perform A* search on our map. We've included the A* pseudocode from Module 3 below.
![A* Pseudocode]
This function will be implemented in the `a_star_search()` function below. As with Dijkstra's search, we should make use of the `get_path()` helper function above. As before, we should find the shortest path from the origin to the goal in the graph, but this time we should use A* with the distance heuristic given above.
"""

# for a given graph, origin vertex key, and goal vertex key,
# computes the shortest path in the graph from the origin vertex
# to the goal vertex using A* search.
# returns the shortest path as a list of vertex keys.
def a_star_search(origin_key, goal_key, graph):
    # rhe priority queue of open vertices we've reached.
    # keys are the vertex keys, vals are the accumulated
    # distances plus the heuristic estimates of the distance
    # to go.
    open_queue = priority_dict.priority_dict({})

    # the dictionary of closed vertices we've processed.
    closed_dict = {}

    # the dictionary of predecessors for each vertex.
    predecessors = {}

    # the dictionary that stores the best cost to reach each
    # vertex found so far.
    costs = {}

    # get the spatial data for each vertex as a dictionary.
    node_data = graph.nodes(True)

    # add the origin to the open queue and the costs dictionary.
    costs[origin_key] = 0.0
    open_queue[origin_key] = distance_heuristic(origin_key, goal_key, node_data)

    # iterate through the open queue, until we find the goal.
    # each time, perform an A* update on the queue.
    # todo: Implement the A* update loop.
    goal_found = False
    while (open_queue):
        u, uheuristic = open_queue.pop_smallest()
        ucost = costs[u]
        if u == goal_key:
            goal_found = True
            break
        for edge_dict in graph.out_edges([u], data=True):
            v = edge_dict[1]
            if v in closed_dict:
                continue
            uvcost = edge_dict[2]['length']
            if v not in open_queue:
                costs[v] = ucost + uvcost
                open_queue[v] = ucost + uvcost + distance_heuristic(v, goal_key, node_data)
                predecessors[v] = u
            else:
                vcost = costs[v]
                if ucost + uvcost < vcost:
                    costs[v] = ucost + uvcost
                    open_queue[v] = ucost + uvcost + distance_heuristic(v, goal_key, node_data)
                    predecessors[v] = u
        closed_dict[u] = 1

    # if we get through entire priority queue without finding the goal,
    # something is wrong.
    if not goal_found:
        raise ValueError("Goal not found in search.")

    # construct the path from the predecessors dictionary.
    return get_path(origin_key, goal_key, predecessors)

"""Once this function has been implemented, run the box below to see if our output matches that of the library function at the start of the notebook."""

path = a_star_search(origin, destination, map_graph)
fig, ax = ox.plot_graph_route(map_graph, path)